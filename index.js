#!/usr/bin/env node

const ArgumentParser = require('argparse').ArgumentParser
const walk = require('./walk')

const fs = require('fs')
const path = require('path')
const { promisify } = require('util')

const readFile = promisify(fs.readFile)
const writeFile = promisify(fs.writeFile)

const parser = new ArgumentParser({
  version: '0.1.0',
  addHelp: true,
  description: 'Lightweight API documentation generator',
})

parser.addArgument('-t', {
  help: 'Template filename',
  metavar: 'template.md',
  required: true,
})

parser.addArgument('-o', {
  help: 'Output filename',
  metavar: 'output.md',
  required: true,
})

parser.addArgument('--outdir', {
  help: 'Output directory for relative links (overrides -o)',
})

parser.addArgument('--pattern', {
  help: 'Regex pattern the files must match',
  defaultValue: '\.js$',
})

parser.addArgument('dir', {
  help: 'Source search directory',
})

const args = parser.parseArgs()

const pattern = new RegExp(args.pattern)

let endpoints = []

function processFile(file, filename) {
  const lines = file.split(/\r?\n/)

  let jsonStartLine = -1
  let activeEndpoint = null
  let lineIndex = 0

  function doError(message) {
    throw `Line ${lineIndex}: ${message}`
  }

  for (const line of lines) {
    lineIndex++

    const match = line.match(/^\s*\/\/\s?(.*)$/)
    if (!match) {
      if (jsonStartLine >= 0) {
        doError(`Unclosed JSON block at line ${jsonStartLine}`)
      }
      if (activeEndpoint) {
        activeEndpoint.line = lineIndex
        activeEndpoint = null
      }
      continue
    }

    const comment = match[1]

    const apiMatch = comment.match(/@api\s+(\w+)\s+(\S+)\s*/)
    if (apiMatch) {
      const method = apiMatch[1].toUpperCase()
      const url = apiMatch[2]

      activeEndpoint = { filename, method, url, lines: [] }
      endpoints.push(activeEndpoint)
    } else if (activeEndpoint) {
      const jsonRep = comment.replace(/\s*@json\s*{\s*$/, '')
      if (comment !== jsonRep) {
        activeEndpoint.lines.push(jsonRep)
        activeEndpoint.lines.push('```json')
        activeEndpoint.lines.push('{')
        jsonStartLine = lineIndex
      } else if (comment.match(/}\s*/)) {
        jsonStartLine = -1
        activeEndpoint.lines.push('}')
        activeEndpoint.lines.push('```')
      } else {
        activeEndpoint.lines.push(comment)
      }
    }
  }

  if (jsonStartLine >= 0) {
    doError(`Unclosed JSON block at line ${jsonStartLine}`)
  }
}

const outputDir = args.outdir || path.dirname(args.o)

const prettyPath = p => p.replace(/\\/g, '/')

const relativeTemplateDir = (() => {
  const absOutputDir = path.resolve(outputDir)
  const absTemplatePath = path.resolve(args.t)
  const absTemplateDir = path.dirname(absTemplatePath)

  const length = Math.min(absOutputDir.length, absTemplateDir.length) | 0
  let begin = 0
  for (; begin < length; begin++) {
    if (absOutputDir[begin] != absTemplateDir[begin]) break
  }

  const commonRoot = absOutputDir.substr(0, begin)
  const relative = path.relative(commonRoot, absTemplatePath)
  return prettyPath(relative)
})()

const prelude = [
  '<!-- This file is autogenerated, do not modify directly,',
  '     If you wish to edit the contents update the documentation',
  `     comments or the template file: ${relativeTemplateDir} -->`,
]

function processTemplate(template) {
  const lines = template.split(/\r?\n/)

  let result = [...prelude]
  let lineIndex = 0
  let error = null

  function doError(message) {
    error = error || message
    const prefix = `Line ${lineIndex}:`
    console.error(prefix, message)
  }

  for (const line of lines) {
    lineIndex++

    const apiMatch = line.match(/\s*@api\s+(\S+)(\s+(\S+))?\s*/)
    if (apiMatch) {
      const url = apiMatch[1]
      const method = (apiMatch[3] || '').toUpperCase()

      let foundAny = false

      for (const endpoint of endpoints) {
        if (endpoint.url !== url) continue
        if (method && endpoint.method != method) continue

        foundAny = true
        if (endpoint.templateLine !== undefined) {
          console.error(`Line ${lineIndex}: Endpoint already inserted at line ${endpoint.templateLine}`)
          process.exitCode = 1
          continue
        }

        endpoint.templateLine = lineIndex

        let codeUrl = prettyPath(path.relative(outputDir, endpoint.filename))
        if (endpoint.line)
          codeUrl += `#L${endpoint.line}`

        result.push(`### [${endpoint.method} ${endpoint.url}](${codeUrl})`)
        result.push('', ...endpoint.lines)
      }

      if (!foundAny) {
        if (method) doError(`Endpoint not found: ${method} ${url}`)
        else doError(`Endpoint not found: ${url}`)
      }

    } else {
      result.push(line)
    }
  }

  if (error) throw error
  return result
}

walk(args.dir, (dir) => {
  if (!dir.match(pattern)) return
  return readFile(dir, { encoding: 'utf-8' }).then(file => processFile(file, dir))
}).catch((error) => {
  console.error('Failed to process file:', error.file)
  console.error(error.error)
  throw error
}).then(() => {
  return readFile(args.t, { encoding: 'utf-8' }).then(file => processTemplate(file))
}).then((lines) => {
  const str = lines.join('\n')
  return writeFile(args.o, str)
}).catch((error) => {
  process.exitCode = 1
})

